#JS 中的垃圾回收机制

## JS 中的内存生命周期

1. 内存分配： 声明变量、函数、对象并执行的时候，系统自动分配内存；
2. 内存使用： 读写内存，即使用变量、函数等；
3. 内存回收： 使用完后，由 **垃圾回收机制** 自动回收不在使用的内存。

## JS中的垃圾回收机制策略

### 标记清除法

     js中最常用的gc方式。
     这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

1. 标记阶段
   从根对象（js 中的全局对象）开始遍历，把可以访问的对象标记为可到达对象
2. 清除阶段
   对堆内存从头到尾遍历，把没标记的内存回收，清除可到达对象的内存的标记。

**回收时机**：内存耗尽时

**缺点** 
1. 根对象查询不到的对象都会被清除；
2. 可能造成大量内存碎片。

### 引用计数法（基本淘汰）

    此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。
    如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。

**缺点** 
无法处理循环引用

## Chrome V8 垃圾回收算法
Chrome 浏览器所使用的 V8 引擎就是采用的分代回收策略。这个和 Java 回收策略 思想是一致的。目的是通过区分「临时」与「持久」对象；多回收「临时对象区」（**新生代** young generation），少回收「持久对象区」（**老生代** tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。

### V8的内存限制
node中js能使用的内存是有限制的：
>   1. 64位系统下约1.4GB
>   2. 32位系统下约0.7GB

对应分代内存，默认为：

>   1. 32位下，TG->700MB,YG->16MB;  
>   2. 64位下，TG->1.4GB,YG->32MB;

新生代平均分成两块相等的内存空间，叫做semispace。

这个限制在node启动的时候可以通过传递--max-old-space-size 和 --max-new-space-size来调整，如：

```
    node --max-old-space-size=1700 app.js //单位为MB
    node --max-new-space-size=1024 app.js //单位为MB

```
**上述参数在V8初始化时生效，一旦生效就不能再动态改变。**

**限制原因：**
    表层原因：V8最初是设计给浏览器的，不太可能遇到大量使用内存的场景。
    深层原因：V8内存回收机制的限制。例子：1.5G堆内存，一次小垃圾回收要50ms以上，一次非增量的垃圾回收要1s以上。

### V8的分代回收（Generation GC）
> 按内存的不同存活时候将内存分代，对不同分代的内存用更高效的回收算法。

#### V8新生代算法（Scavenge）:
    新生代主要用Scavenge算法进行垃圾回收，Scavenge算法主要采用Cheney算法实现：
Cheney算法是一种采用**复制**实现的回收算法，把堆内存一分为二，每一部分空间称为semispace,两个空间只有一个使用，另一个闲置。
**使用中的semispace被称为From空间，闲置的semispace被成为To空间**
分配内存时先往From空间分配。当开始垃圾回收时，把From空间中的**存活对象（JS标记）**复制到To空间中，释放非存活对象。最后把From空间和To空间角色对换。
**Scavenge算法的缺点：**
只有一半的空间在被使用。

**优点**：
在时间效率上有优异的表现。 Scavenge是典型的牺牲空间换取时间的算法。十分合适在YG中使用。

**晋升：**
当一个对象被多次复制依然存活，它会被认定为生命周期较长的对象，这种对象随后会移动到老生代中，采用新的算法管理。 
**对象从新生代中移动到老生代中的过程称为晋升** 

P.S.在单纯的Scavenge中，存活对象只会在两个semispace中转移。但在分代式GC前提下，每次From中的存活对象复制到To前都要进行检查，在一定条件下，需要对对象完成**晋升**。

**晋升条件**
有没有经历过Scavenge回收；To空间内存占用比大于25%（**占比过高会影响后续内存分配**）

#### V8新生代算法（Mark-Sweep && Mark-Compact）:
Mark-Sweep: *标记清除法*
Mark-Compact: 标记死亡对象，然后在整理时把活着的对象往一端移动，最后清除边界外的内存。

回收算法|Mark-Sweep|Mark-Compact|Scavenge
---|---|---|---
速度|中等|最慢|最快
空间开销|少（有碎片）|少（无碎片）|双倍空间（无碎片）
是否移动对象|否|是|是

#### 增量式标记回收
为了避免js应用逻辑和垃圾回收器看到不一致的情况，gc的3种基本算法都要将应用逻辑暂停下来，等回收结束后再恢复（全停顿/stop the world）。
为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记（incremental marking），也就是**拆分为许多小“步进”，每做完一“步进”就让js应用逻辑执行一小会，垃圾回收与应用逻辑交替执行直到标记阶段完成**。
V8在经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原本的1/6左右。
V8后续还引入了延迟清理（lazy sweeping）与增量式整理（incremental compaction），让清理与整理动作也变成增量式的。同时还计划引入并行标记与并行清理，进一步利用多核性能降低每次停顿的时间。
